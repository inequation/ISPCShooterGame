// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;

public class ShooterGame : ModuleRules
{
	// Path to ISPC compiler binary.
	public static readonly string ISPCExe = "D:\\ispc-v1.9.2-windows\\ispc.exe";

	// Flags with which to compile ISPC source.
	public static readonly string ISPCFlags = "-g --target=sse4-i32x4"; // FIXME

	public static readonly string MakefileName = "ISPC.mak";

	// ISPC sources to build and link.
	public static readonly string[] ISPCSources = new string[]
	{
		"Private/ISPC/Kernels.ispc",
	};

	// Accessors to autogenerated rule details.
	public static string[] ISPCAbsoluteSources { get { return _ISPCAbsoluteSources; } }
	public static string[] ISPCObjects { get { return _ISPCObjects; } }
	public static string[] ISPCHeaders { get { return _ISPCHeaders; } }

	// Containers for autogenerated rule details.
	private static string[] _ISPCAbsoluteSources;
	private static string[] _ISPCObjects;
	private static string[] _ISPCHeaders;

	// Guard to make sure that the target has been correctly set up.
	private static bool bISPCHasBeenSetupInTarget = false;

	// Sets up ISPC build rules as custom pre-build step in the passed in target, and caches autogenerated rule details.
	public static void SetupISPCRules(TargetRules Target)
	{
		string ModuleName = new StackFrame().GetMethod().DeclaringType.ToString();

		string PlatformIntermediateDir = Path.Combine
		(
			Target.ProjectFile.Directory.FullName,
			"Intermediate",
			"Build",
			Target.Platform.ToString(),
			/*UEBuildPlatform.GetBuildPlatform(Target.Platform).GetFolderNameForArchitecture*/(Target.Architecture)
		);

		string ModuleSourceDirectory = Path.Combine
		(
			Target.ProjectFile.Directory.FullName,
			"Source",
			ModuleName
		);
		Debug.Assert(File.Exists(Path.Combine(ModuleSourceDirectory, ModuleName + ".Build.cs")), string.Format("`ModuleSourceDirectory` needs to point at the `Source` directory of module `{0}`", ModuleName));

		string ObjectDir = Path.Combine
		(
			PlatformIntermediateDir,
			Target.Name,
			Target.Configuration.ToString(),
			ModuleName
		);

		string HeaderDir = Path.Combine
		(
			PlatformIntermediateDir,
			Target.Type == TargetType.Editor ? "UE4Editor" : "UE4",
			"Inc",
			ModuleName
		);

		Directory.CreateDirectory(ObjectDir);
		Directory.CreateDirectory(HeaderDir);

		string MakefilePath = Path.Combine(ObjectDir, MakefileName);
		Log.WriteLine(LogEventType.Console, "Generating ISPC makefile {0}", MakefilePath);
		using (StreamWriter Makefile = new StreamWriter(MakefilePath))
		{
			Makefile.WriteLine("# Generated automatically by module rules, do not modify");
			Makefile.WriteLine();

			Makefile.WriteLine("ISPC=" + ISPCExe);
			Makefile.WriteLine("ISPCFLAGS=" + ISPCFlags);
			Makefile.WriteLine("SOURCE_DIR=" + ModuleSourceDirectory);
			Makefile.WriteLine("HEADER_DIR=" + HeaderDir);
			Makefile.WriteLine();

			List<string> AbsoluteSources = new List<string>();
			List<string> Objects = new List<string>();
			List<string> AbsoluteObjects = new List<string>();
			List<string> Headers = new List<string>();
			foreach (string RelativeSource in ISPCSources)
			{
				string BaseName = Path.GetFileName(RelativeSource);
				string Object = BaseName.Replace(".ispc", ".ispc.o");
				string Header = BaseName.Replace(".ispc", ".ispc.h");
				string AbsSource = Path.Combine(ModuleSourceDirectory, RelativeSource);
				string AbsObject = Path.Combine(ObjectDir, Object);
				string AbsHeader = Path.Combine(HeaderDir, Header);

				AbsoluteSources.Add(AbsSource);
				Objects.Add(Object);
				AbsoluteObjects.Add(AbsObject);
				Headers.Add(AbsHeader);

				Makefile.WriteLine("# ISPC object file.");
				Makefile.WriteLine("{0}: \"$(SOURCE_DIR){1}\"", Object, Path.DirectorySeparatorChar + RelativeSource);
				Makefile.WriteLine("\t$(ISPC) \"$(SOURCE_DIR){0}\" -o \"{1}\" -h \"$(HEADER_DIR){2}\" $(ISPCFLAGS)",
					Path.DirectorySeparatorChar + RelativeSource,
					Object,
					Path.DirectorySeparatorChar + Header);
				Makefile.WriteLine("# ISPC C++ autogenerated header. Actually built together with the object file, so consider this indirect dependency a hack.");
				Makefile.WriteLine("\"$(HEADER_DIR){0}\": {1}", Path.DirectorySeparatorChar + Header, Object);
				Makefile.WriteLine();
			}
			Makefile.WriteLine("# Phony target for building all objects.");
			Makefile.WriteLine("all: " + string.Join(" ", Objects));
			_ISPCAbsoluteSources = AbsoluteSources.ToArray();
			_ISPCObjects = AbsoluteObjects.ToArray();
			_ISPCHeaders = Headers.ToArray();
		}

		bool bUseGNUMake = System.Environment.OSVersion.Platform == System.PlatformID.Unix || System.Environment.OSVersion.Platform == System.PlatformID.MacOSX;
		// Use /C to silence nmake's output because the copyright notice is emitted to stderr and UBT interprets that as error.
		string MakeCmdline = bUseGNUMake ? "make -f" : "nmake /C /F";
		
		Target.PreBuildSteps.Add(string.Format("pushd {0} && " +
			"echo Building ISPC kernels && " +
			"{1} {2} all" +
			" && popd",
			ObjectDir,
			MakeCmdline,
			MakefilePath
			));

		bISPCHasBeenSetupInTarget = true;
	}

	// Sets up module rules from cached autogenerated ISPC rules.
	private void SetModuleRulesFromISPC(ReadOnlyTargetRules Target)
	{
		Debug.Assert(bISPCHasBeenSetupInTarget, string.Format("`{0}.SetupISPCRules(this);` needs to be called first from target {1}", GetType().ToString(), Target.Name));
		PublicAdditionalLibraries.AddRange(ISPCObjects);
		PublicAdditionalShadowFiles.AddRange(ISPCObjects);

		// FIXME: These shouldn't be necessary, but I still haven't found a proper way to relink the module when ISPC is rebuilt.
		/*ExternalDependencies.AddRange(ISPCAbsoluteSources);
		ExternalDependencies.AddRange(ISPCObjects);
		ExternalDependencies.AddRange(ISPCHeaders);*/
	}

	public ShooterGame(ReadOnlyTargetRules Target) : base(Target)
	{
		SetModuleRulesFromISPC(Target);

		PrivateIncludePaths.AddRange(
			new string[] { 
				"ShooterGame/Classes/Player",
				"ShooterGame/Private",
				"ShooterGame/Private/UI",
				"ShooterGame/Private/UI/Menu",
				"ShooterGame/Private/UI/Style",
				"ShooterGame/Private/UI/Widgets",
			}
		);

		PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"CoreUObject",
				"Engine",
				"OnlineSubsystem",
				"OnlineSubsystemUtils",
				"AssetRegistry",
				"AIModule",
				"GameplayTasks",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new string[] {
				"InputCore",
				"Slate",
				"SlateCore",
				"ShooterGameLoadingScreen",
				"Json",
				"ApplicationCore"
			}
		);

		DynamicallyLoadedModuleNames.AddRange(
			new string[] {
				"OnlineSubsystemNull",
				"NetworkReplayStreaming",
				"NullNetworkReplayStreaming",
				"HttpNetworkReplayStreaming",
				"LocalFileNetworkReplayStreaming"
			}
		);

		PrivateIncludePathModuleNames.AddRange(
			new string[] {
				"NetworkReplayStreaming"
			}
		);
	}
}
