// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;

public class ShooterGame : ModuleRules
{
	// Minimum supported ISPC version.
	public static readonly System.Version MinimumISPCVersion = new System.Version(1, 9, 3);
	public static readonly string MakefileName = "ISPC.mak";
	// Target CPU to use for desktop platforms.
	public static readonly string TargetDesktopCPU = "corei7";
	// Whether to use the ISPC instrumentation.
	public static bool bUseInstrumentation = false;

	// Accessors to autogenerated rule details.
	public static string[] ISPCObjects { get { return _ISPCObjects; } }

	// Containers for autogenerated rule details.
	private static string[] _ISPCObjects;

	// Guard to make sure that the target has been correctly set up.
	private static bool bISPCHasBeenSetupInTarget = false;

	public static string GetISPCExecutablePath()
	{
		string[] Candidates =
		{
			// FIXME: Un-hardcode this.
			@"D:\projects\ispc\x64\Release\ispc.exe",
			@"D:\projects\ispc\Release\ispc.exe",
			@"E:\ispc-v1.9.2-windows\ispc.exe",
			@"D:\ispc-v1.9.2-windows\ispc.exe"
		};
		foreach (string Candidate in Candidates)
		{
			if (File.Exists(Candidate))
			{
				return Candidate;
			}
		}
		Log.WriteLine(LogEventType.Warning, "Could not find path to the ISPC executable");
		return (System.Environment.OSVersion.Platform == System.PlatformID.Unix || System.Environment.OSVersion.Platform == System.PlatformID.MacOSX)
			? "ispc" : "ispc.exe";
	}
	
	public static System.Version GetISPCVersion()
	{
		string Output = "";
		Process ISPCProc = new Process();
		ISPCProc.StartInfo = new ProcessStartInfo(GetISPCExecutablePath(), "--version");
		ISPCProc.OutputDataReceived += (Sender, Args) => { Output += Args.Data; };
		ISPCProc.ErrorDataReceived += (Sender, Args) => { Output += Args.Data; };
		Utils.RunLocalProcess(ISPCProc);
		const string Identifier = "Intel(r) SPMD Program Compiler (ispc),";
		if (Output.StartsWith(Identifier))
		{
			Output = Output.Substring(Identifier.Length).TrimStart(' ');
			int Space = Output.IndexOf(' ');
			if (Space >= 0)
			{
				Output = Output.Substring(0, Space);
			}
			char[] VersionCharacters = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.' };
			int NonVersion = Output.LastIndexOfAny(VersionCharacters);
			if (NonVersion >= 0)
			{
				Output = Output.Substring(0, NonVersion + 1);
			}
			try
			{
				return System.Version.Parse(Output);
			}
			catch { }	// Intentional no-op.
		}
		return new System.Version(-1, -1, -1);
	}

	public static string GetISPCFlags(UnrealTargetPlatform Platform, UnrealTargetConfiguration Configuration, bool bInstrumentation)
	{
		string Flags = "-g";	// We always want debugging symbols.
		if (bInstrumentation)
		{
			Flags += " --instrument";
		}
		switch (Platform)
		{
			case UnrealTargetPlatform.Win32:
				Flags += " --target=sse2-i32x4";
				break;
			// All relevant x64-based platforms have SSE 4.2.
			case UnrealTargetPlatform.Win64:
			case UnrealTargetPlatform.Mac:
			case UnrealTargetPlatform.Linux:
			case UnrealTargetPlatform.AllDesktop:
				Flags += " --cpu=" + TargetDesktopCPU;
				Flags += " --target=sse4-i32x4";
				break;
			case UnrealTargetPlatform.XboxOne:
			case UnrealTargetPlatform.PS4:
				Flags += " --target=sse4-i32x4";
				break;
			// ARM-based mobiles have NEON.
			case UnrealTargetPlatform.IOS:
			case UnrealTargetPlatform.Android:
			case UnrealTargetPlatform.TVOS:
			case UnrealTargetPlatform.Switch:
				Flags += " --target=neon-i32x4";
				break;
			default:
				throw new System.Exception(string.Format("Platform {0} is unsupported by ISPC", System.Enum.GetName(typeof(UnrealTargetPlatform), Platform)));
		}
		switch (Configuration)
		{
			case UnrealTargetConfiguration.Development:
			case UnrealTargetConfiguration.Shipping:
			case UnrealTargetConfiguration.Test:
				Flags += " -O3";
				break;
		}
		return Flags;
	}

	public static string[] GetISPCSources(string ModuleSourceDirectory)
	{
		string[] AbsoluteSources = Directory.GetFiles(ModuleSourceDirectory, "*.ispc", SearchOption.AllDirectories);
		string[] RelativeSources = new string[AbsoluteSources.Length];
		int Index = 0;
		foreach (string Abs in AbsoluteSources)
		{
			RelativeSources[Index++] = Utils.MakePathRelativeTo(Abs, ModuleSourceDirectory);
		}
		return RelativeSources;
	}

	// Sets up ISPC build rules as custom pre-build step in the passed in target, and caches autogenerated rule details.
	public static void SetupISPCRules(TargetRules Target)
	{
		System.Version ISPCVersion = GetISPCVersion();
		if (ISPCVersion.Major < 0)
		{
			Log.WriteLine(LogEventType.Warning, "Could not determine the ISPC version");
		}
		else if (ISPCVersion < MinimumISPCVersion)
		{
			throw new System.Exception(string.Format("ISPC version {0} is not recent enough, a minimum of {1} is required",
				ISPCVersion.ToString(), MinimumISPCVersion.ToString()));
		}

		string ModuleName = new StackFrame().GetMethod().DeclaringType.ToString();

		string PlatformIntermediateDir = Path.Combine
		(
			Target.ProjectFile.Directory.FullName,
			"Intermediate",
			"Build",
			Target.Platform.ToString(),
			/*UEBuildPlatform.GetBuildPlatform(Target.Platform).GetFolderNameForArchitecture*/(Target.Architecture)
		);

		string ModuleSourceDirectory = Path.Combine
		(
			Target.ProjectFile.Directory.FullName,
			"Source",
			ModuleName
		);
		Debug.Assert(File.Exists(Path.Combine(ModuleSourceDirectory, ModuleName + ".Build.cs")), string.Format("`ModuleSourceDirectory` needs to point at the `Source` directory of module `{0}`", ModuleName));

		string ObjectDir = Path.Combine
		(
			PlatformIntermediateDir,
			Target.Name,
			Target.Configuration.ToString(),
			ModuleName
		);

		string HeaderDir = Path.Combine
		(
			PlatformIntermediateDir,
			Target.Type == TargetType.Editor ? "UE4Editor" : "UE4",
			"Inc",
			ModuleName
		);

		Directory.CreateDirectory(ObjectDir);
		Directory.CreateDirectory(HeaderDir);

		var Sources = GetISPCSources(ModuleSourceDirectory);

		bool bUseGNUMake = System.Environment.OSVersion.Platform == System.PlatformID.Unix || System.Environment.OSVersion.Platform == System.PlatformID.MacOSX;

		string MakefilePath = Path.Combine(ObjectDir, MakefileName);
		Log.WriteLine(LogEventType.Console, "Generating ISPC makefile {0}", MakefilePath);
		using (StreamWriter Makefile = new StreamWriter(MakefilePath))
		{
			Makefile.WriteLine("# Generated automatically by module rules, do not modify");
			Makefile.WriteLine();

			Makefile.WriteLine("ISPC=" + GetISPCExecutablePath());
			Makefile.WriteLine("ISPCFLAGS=" + GetISPCFlags(Target.Platform, Target.Configuration, bUseInstrumentation));
			Makefile.WriteLine("SOURCE_DIR=" + ModuleSourceDirectory);
			Makefile.WriteLine("HEADER_DIR=" + HeaderDir);
			Makefile.WriteLine();

			List<string> AbsoluteSources = new List<string>();
			List<string> Objects = new List<string>();
			List<string> AbsoluteObjects = new List<string>();
			List<string> Headers = new List<string>();
			List<string> Dependencies = new List<string>();
			foreach (string RelativeSource in Sources)
			{
				string BaseName = Path.GetFileName(RelativeSource);
				string Object = BaseName.Replace(".ispc", ".ispc.o");
				string Header = BaseName.Replace(".ispc", ".ispc.h");
				string Dependency = BaseName.Replace(".ispc", ".ispc.d");
				string AbsSource = Path.Combine(ModuleSourceDirectory, RelativeSource);
				string AbsObject = Path.Combine(ObjectDir, Object);
				string AbsHeader = Path.Combine(HeaderDir, Header);

				AbsoluteSources.Add(AbsSource);
				Objects.Add(Object);
				AbsoluteObjects.Add(AbsObject);
				Headers.Add(AbsHeader);
				Dependencies.Add(Dependency);

				Makefile.WriteLine(bUseGNUMake ? "ifdef $(HAVE_DEPENDENCIES)" : "!IFDEF HAVE_DEPENDENCIES");

					Makefile.WriteLine("# ISPC object file.");
					Makefile.WriteLine("{0} {1}", bUseGNUMake ? "include" : "!INCLUDE", Dependency);
					Makefile.WriteLine("\t$(ISPC) \"$(SOURCE_DIR){0}\" -o $@ -h \"$(HEADER_DIR){1}\" $(ISPCFLAGS)",
						Path.DirectorySeparatorChar + RelativeSource,
						Path.DirectorySeparatorChar + Header);

					Makefile.WriteLine("# ISPC C++ autogenerated header. Actually built together with the object file, so consider this indirect dependency a hack.");
					Makefile.WriteLine("\"$(HEADER_DIR){0}\": {1}", Path.DirectorySeparatorChar + Header, Object);

				Makefile.WriteLine(bUseGNUMake ? "else" : "!ELSE");

					Makefile.WriteLine("# ISPC object dependency file.");
					Makefile.WriteLine("{0}: \"$(SOURCE_DIR){1}\"", Dependency, Path.DirectorySeparatorChar + RelativeSource);
					Makefile.WriteLine("\t$(ISPC) $? -M -MF $@ -MT {0} --wno-perf $(ISPCFLAGS)", Object);

				Makefile.WriteLine(bUseGNUMake ? "endif" : "!ENDIF");

				Makefile.WriteLine();
			}
			Makefile.WriteLine("# Phony target for building all dependency files.");
			Makefile.WriteLine("depend: " + string.Join(" ", Dependencies));
			Makefile.WriteLine("# Phony target for building all objects.");
			Makefile.WriteLine("all: " + string.Join(" ", Objects));

			_ISPCObjects = AbsoluteObjects.ToArray();
		}

		// Use /C to silence nmake's output because the copyright notice is emitted to stderr and UBT interprets that as error.
		string MakeCmdline = bUseGNUMake ? "make -f" : "nmake /C /F";
		string PreTarget = "HAVE_DEPENDENCIES=1";
		string PostTarget = "";
		if (bUseGNUMake)
		{
			PostTarget = PreTarget;
			PreTarget = "";
		}
		
		Target.PreBuildSteps.Add(string.Format("pushd \"{0}\" && " +
			"echo Gathering ISPC dependencies && " +
			"{1} \"{2}\" depend && " +
			"echo Building ISPC kernels && " +
			"{1} \"{2}\" {3} all {4} &&" +
			"popd",
			ObjectDir,
			MakeCmdline,
			MakefileName,
			PreTarget,
			PostTarget
			));

		bISPCHasBeenSetupInTarget = true;
	}

	// Sets up module rules from cached autogenerated ISPC rules.
	private void SetModuleRulesFromISPC(ReadOnlyTargetRules Target)
	{
		Debug.Assert(bISPCHasBeenSetupInTarget, string.Format("`{0}.SetupISPCRules(this);` needs to be called first from target {1}", GetType().ToString(), Target.Name));
		PublicAdditionalLibraries.AddRange(ISPCObjects);
		PublicAdditionalShadowFiles.AddRange(ISPCObjects);
	}

	public ShooterGame(ReadOnlyTargetRules Target) : base(Target)
	{
		SetModuleRulesFromISPC(Target);

		PrivateIncludePaths.AddRange(
			new string[] { 
				"ShooterGame/Classes/Player",
				"ShooterGame/Private",
				"ShooterGame/Private/UI",
				"ShooterGame/Private/UI/Menu",
				"ShooterGame/Private/UI/Style",
				"ShooterGame/Private/UI/Widgets",
			}
		);

		PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"CoreUObject",
				"Engine",
				"OnlineSubsystem",
				"OnlineSubsystemUtils",
				"AssetRegistry",
				"AIModule",
				"GameplayTasks",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new string[] {
				"InputCore",
				"Slate",
				"SlateCore",
				"ShooterGameLoadingScreen",
				"Json",
				"ApplicationCore"
			}
		);

		DynamicallyLoadedModuleNames.AddRange(
			new string[] {
				"OnlineSubsystemNull",
				"NetworkReplayStreaming",
				"NullNetworkReplayStreaming",
				"HttpNetworkReplayStreaming",
				"LocalFileNetworkReplayStreaming"
			}
		);

		PrivateIncludePathModuleNames.AddRange(
			new string[] {
				"NetworkReplayStreaming"
			}
		);
	}
}
